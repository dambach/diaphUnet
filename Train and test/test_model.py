# -*- coding: utf-8 -*-
"""Test_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YfV3NSCobK7cVgmtjf0gCQKm1ZnmBNcn
"""

import numpy as np                        # pour effectuer des opérations sur les array/tableaux
import matplotlib.pyplot as plt           # pour visualiser les images
import torch                              # pour construire le modèle de réseaux de neurones
from torch.autograd import Variable       # pour transformer les tableaux numpy en tensors
from torch.optim import Adam              # pour optimiser la fonction perte
import cv2
import time

def test_model(model, xtest, ytest, num_epoch, batch, loss_fn, save_epoch):
  optimizer = torch.optim.Adam(model.parameters(), lr = 1e-4,  weight_decay = 1e-2)
  test_losses = []
  acc_test = []
  dice_test = []
  
  t1 = time.time()
  test_loss = 0.0
  
  for u, v, mu, mv in zip(ytrain, ytest):
    test_loader = torch.utils.data.DataLoader(dataset = v, batch_size = int(batch/2), shuffle = False)
    mtest_loader = torch.utils.data.DataLoader(dataset = mv, batch_size = int(batch/2), shuffle = False)
    
    num_correct = 0
    num_pixels = 0
    dice_score = 0
    model.eval()
    for img2, mimg2 in zip(test_loader, mtest_loader):
      img2 = img2.to(device)
      y_pred2 = model(img2)
      mimg2 = Variable(mimg2).type(torch.FloatTensor).to(device)
      loss = loss_fn(y_pred2, mimg2)
      test_loss += loss.item()*img2.size(0)
      
      with torch.no_grad():
        img2 = img2.to(device)
        mimg2 = mimg2.to(device)
        preds = torch.sigmoid(y_pred2)
        preds = (preds > 0.5).float()
        num_correct += (preds == mimg2).sum()
        num_pixels += torch.numel(preds)
        dice_score += (2 * (preds * mimg2).sum()) / ((preds + mimg2).sum() + 1e-8)
        dice_score /= len(test_loader)
        acc2 = num_correct/num_pixels*100
        dice2 = 1 - dice_score
        
  acc_test.append(acc2)
  dice_test.append(dice2)
  test_loss = test_loss/len(test_loader.sampler)
  
  test_losses.append(test_loss)
  t2 = time.time()  
  if epoch % save_epoch == 0:
    path = '/content/drive/MyDrive/Colab Notebooks/Data image/image' + str(epoch) + '.pt'
    torch.save(y_pred2, path)
    print('Epoch : {} Test Loss : {:.4f} Accuracy test : {:.4f} Dice test : {:.4f} Temps : {:.4f} min'.format(epoch, test_loss, acc2, dice2, (t2-t1)/60))
    fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(20, 15),
                           gridspec_kw={'width_ratios': [3, 3],
                                          'height_ratios': [3, 3],
                                          'wspace': 0.4,
                                          'hspace': 0.4})
    # Loss
    ax[0][0].plot(list(range(epoch)), test_losses[:epoch], label = 'test_losses')
    ax[0][0].set_xlabel("Epoch", fontsize = 18)
    ax[0][0].set_ylabel("Loss", fontsize = 18)
    ax[0][0].set_xlim([0, epoch-1])
    ax[0][0].set_ylim([0, 1.5*max(test_losses)])
    ax[0][0].legend(prop = {'size':16}, loc = 'best')
 
    # Précision
    ax[0][1].plot(list(range(epoch)), acc_test, label = 'Accuracy test')
    ax[0][1].set_xlabel("Epoch", fontsize = 18)
    ax[0][1].set_ylabel("Accuracy", fontsize = 18)
    ax[0][1].legend(prop = {'size':16}, loc = 'lower right')
 
    # Image prédite
    J = np.random.randint(len(y_pred2))
    ax[1][0].imshow(y_pred2[J,0,:,:].cpu().detach().numpy() > 0.5)
    ax[1][0].set_title('Image prédite')
    ax[1][0].axis('off')

    # Image vérité terrain
    ax[1][1].imshow(mimg2[J,0,:,:].cpu().detach().numpy())
    ax[1][1].set_title('Image vérité terrain')
    ax[1][1].axis('off')
 
    plt.show()
    plt.pause(1e-99)
  else:
    print('Epoch : {} Test Loss : {:.4f} Accuracy test : {:.4f} Dice test : {:.4f} Temps : {:.4f} min'.format(epoch, test_loss, acc2, dice2, (t2-t1)/60))